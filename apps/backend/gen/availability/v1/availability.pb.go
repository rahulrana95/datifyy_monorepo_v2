// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: availability/v1/availability.proto

package availabilityv1

import (
	v1 "github.com/datifyy/backend/gen/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Type of date/meeting
type DateType int32

const (
	DateType_DATE_TYPE_UNSPECIFIED   DateType = 0
	DateType_DATE_TYPE_ONLINE        DateType = 1 // Virtual/Video date
	DateType_DATE_TYPE_OFFLINE       DateType = 2 // In-person date at a location
	DateType_DATE_TYPE_OFFLINE_EVENT DateType = 3 // In-person at an event
)

// Enum value maps for DateType.
var (
	DateType_name = map[int32]string{
		0: "DATE_TYPE_UNSPECIFIED",
		1: "DATE_TYPE_ONLINE",
		2: "DATE_TYPE_OFFLINE",
		3: "DATE_TYPE_OFFLINE_EVENT",
	}
	DateType_value = map[string]int32{
		"DATE_TYPE_UNSPECIFIED":   0,
		"DATE_TYPE_ONLINE":        1,
		"DATE_TYPE_OFFLINE":       2,
		"DATE_TYPE_OFFLINE_EVENT": 3,
	}
)

func (x DateType) Enum() *DateType {
	p := new(DateType)
	*p = x
	return p
}

func (x DateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DateType) Descriptor() protoreflect.EnumDescriptor {
	return file_availability_v1_availability_proto_enumTypes[0].Descriptor()
}

func (DateType) Type() protoreflect.EnumType {
	return &file_availability_v1_availability_proto_enumTypes[0]
}

func (x DateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DateType.Descriptor instead.
func (DateType) EnumDescriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{0}
}

// Offline location details for in-person dates
type OfflineLocation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the place (e.g., "Starbucks Downtown")
	PlaceName string `protobuf:"bytes,1,opt,name=place_name,json=placeName,proto3" json:"place_name,omitempty"`
	// Full address
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// City
	City string `protobuf:"bytes,3,opt,name=city,proto3" json:"city,omitempty"`
	// State/Province
	State string `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	// Country
	Country string `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty"`
	// Postal/ZIP code
	Zipcode string `protobuf:"bytes,6,opt,name=zipcode,proto3" json:"zipcode,omitempty"`
	// Latitude
	Latitude float64 `protobuf:"fixed64,7,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// Longitude
	Longitude float64 `protobuf:"fixed64,8,opt,name=longitude,proto3" json:"longitude,omitempty"`
	// Google Maps place ID (for easy lookup)
	GooglePlaceId string `protobuf:"bytes,9,opt,name=google_place_id,json=googlePlaceId,proto3" json:"google_place_id,omitempty"`
	// Google Maps URL
	GoogleMapsUrl string `protobuf:"bytes,10,opt,name=google_maps_url,json=googleMapsUrl,proto3" json:"google_maps_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OfflineLocation) Reset() {
	*x = OfflineLocation{}
	mi := &file_availability_v1_availability_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OfflineLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OfflineLocation) ProtoMessage() {}

func (x *OfflineLocation) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OfflineLocation.ProtoReflect.Descriptor instead.
func (*OfflineLocation) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{0}
}

func (x *OfflineLocation) GetPlaceName() string {
	if x != nil {
		return x.PlaceName
	}
	return ""
}

func (x *OfflineLocation) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *OfflineLocation) GetCity() string {
	if x != nil {
		return x.City
	}
	return ""
}

func (x *OfflineLocation) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

func (x *OfflineLocation) GetCountry() string {
	if x != nil {
		return x.Country
	}
	return ""
}

func (x *OfflineLocation) GetZipcode() string {
	if x != nil {
		return x.Zipcode
	}
	return ""
}

func (x *OfflineLocation) GetLatitude() float64 {
	if x != nil {
		return x.Latitude
	}
	return 0
}

func (x *OfflineLocation) GetLongitude() float64 {
	if x != nil {
		return x.Longitude
	}
	return 0
}

func (x *OfflineLocation) GetGooglePlaceId() string {
	if x != nil {
		return x.GooglePlaceId
	}
	return ""
}

func (x *OfflineLocation) GetGoogleMapsUrl() string {
	if x != nil {
		return x.GoogleMapsUrl
	}
	return ""
}

// A single availability slot
type AvailabilitySlot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique slot ID
	SlotId string `protobuf:"bytes,1,opt,name=slot_id,json=slotId,proto3" json:"slot_id,omitempty"`
	// User ID who created this slot
	UserId string `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Start datetime (Unix timestamp in seconds)
	StartTime int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End datetime (Unix timestamp in seconds)
	EndTime int64 `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Type of date (online/offline/offline_event)
	DateType DateType `protobuf:"varint,5,opt,name=date_type,json=dateType,proto3,enum=datifyy.availability.v1.DateType" json:"date_type,omitempty"`
	// Offline location details (required for OFFLINE and OFFLINE_EVENT types)
	OfflineLocation *OfflineLocation `protobuf:"bytes,6,opt,name=offline_location,json=offlineLocation,proto3" json:"offline_location,omitempty"`
	// Optional notes for the slot
	Notes string `protobuf:"bytes,7,opt,name=notes,proto3" json:"notes,omitempty"`
	// Created timestamp
	CreatedAt *v1.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Updated timestamp
	UpdatedAt     *v1.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AvailabilitySlot) Reset() {
	*x = AvailabilitySlot{}
	mi := &file_availability_v1_availability_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailabilitySlot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailabilitySlot) ProtoMessage() {}

func (x *AvailabilitySlot) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailabilitySlot.ProtoReflect.Descriptor instead.
func (*AvailabilitySlot) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{1}
}

func (x *AvailabilitySlot) GetSlotId() string {
	if x != nil {
		return x.SlotId
	}
	return ""
}

func (x *AvailabilitySlot) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *AvailabilitySlot) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *AvailabilitySlot) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *AvailabilitySlot) GetDateType() DateType {
	if x != nil {
		return x.DateType
	}
	return DateType_DATE_TYPE_UNSPECIFIED
}

func (x *AvailabilitySlot) GetOfflineLocation() *OfflineLocation {
	if x != nil {
		return x.OfflineLocation
	}
	return nil
}

func (x *AvailabilitySlot) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *AvailabilitySlot) GetCreatedAt() *v1.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *AvailabilitySlot) GetUpdatedAt() *v1.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

// Input slot for submission (without generated fields)
type AvailabilitySlotInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Start datetime (Unix timestamp in seconds)
	StartTime int64 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End datetime (Unix timestamp in seconds)
	EndTime int64 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Type of date (online/offline/offline_event)
	DateType DateType `protobuf:"varint,3,opt,name=date_type,json=dateType,proto3,enum=datifyy.availability.v1.DateType" json:"date_type,omitempty"`
	// Offline location details (required for OFFLINE and OFFLINE_EVENT types)
	OfflineLocation *OfflineLocation `protobuf:"bytes,4,opt,name=offline_location,json=offlineLocation,proto3" json:"offline_location,omitempty"`
	// Optional notes for the slot
	Notes         string `protobuf:"bytes,5,opt,name=notes,proto3" json:"notes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AvailabilitySlotInput) Reset() {
	*x = AvailabilitySlotInput{}
	mi := &file_availability_v1_availability_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailabilitySlotInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailabilitySlotInput) ProtoMessage() {}

func (x *AvailabilitySlotInput) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailabilitySlotInput.ProtoReflect.Descriptor instead.
func (*AvailabilitySlotInput) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{2}
}

func (x *AvailabilitySlotInput) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *AvailabilitySlotInput) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *AvailabilitySlotInput) GetDateType() DateType {
	if x != nil {
		return x.DateType
	}
	return DateType_DATE_TYPE_UNSPECIFIED
}

func (x *AvailabilitySlotInput) GetOfflineLocation() *OfflineLocation {
	if x != nil {
		return x.OfflineLocation
	}
	return nil
}

func (x *AvailabilitySlotInput) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

// Get availability request
type GetAvailabilityRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional user ID (if not provided, returns current user's availability)
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Optional start time filter (Unix timestamp)
	FromTime int64 `protobuf:"varint,2,opt,name=from_time,json=fromTime,proto3" json:"from_time,omitempty"`
	// Optional end time filter (Unix timestamp)
	ToTime int64 `protobuf:"varint,3,opt,name=to_time,json=toTime,proto3" json:"to_time,omitempty"`
	// Pagination
	Pagination    *v1.PaginationRequest `protobuf:"bytes,4,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAvailabilityRequest) Reset() {
	*x = GetAvailabilityRequest{}
	mi := &file_availability_v1_availability_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAvailabilityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAvailabilityRequest) ProtoMessage() {}

func (x *GetAvailabilityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAvailabilityRequest.ProtoReflect.Descriptor instead.
func (*GetAvailabilityRequest) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{3}
}

func (x *GetAvailabilityRequest) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *GetAvailabilityRequest) GetFromTime() int64 {
	if x != nil {
		return x.FromTime
	}
	return 0
}

func (x *GetAvailabilityRequest) GetToTime() int64 {
	if x != nil {
		return x.ToTime
	}
	return 0
}

func (x *GetAvailabilityRequest) GetPagination() *v1.PaginationRequest {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// Get availability response
type GetAvailabilityResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of availability slots
	Slots []*AvailabilitySlot `protobuf:"bytes,1,rep,name=slots,proto3" json:"slots,omitempty"`
	// Pagination info
	Pagination    *v1.PaginationResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAvailabilityResponse) Reset() {
	*x = GetAvailabilityResponse{}
	mi := &file_availability_v1_availability_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAvailabilityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAvailabilityResponse) ProtoMessage() {}

func (x *GetAvailabilityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAvailabilityResponse.ProtoReflect.Descriptor instead.
func (*GetAvailabilityResponse) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{4}
}

func (x *GetAvailabilityResponse) GetSlots() []*AvailabilitySlot {
	if x != nil {
		return x.Slots
	}
	return nil
}

func (x *GetAvailabilityResponse) GetPagination() *v1.PaginationResponse {
	if x != nil {
		return x.Pagination
	}
	return nil
}

// Submit availability request (bulk create)
type SubmitAvailabilityRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of availability slots to create
	Slots         []*AvailabilitySlotInput `protobuf:"bytes,1,rep,name=slots,proto3" json:"slots,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubmitAvailabilityRequest) Reset() {
	*x = SubmitAvailabilityRequest{}
	mi := &file_availability_v1_availability_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubmitAvailabilityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubmitAvailabilityRequest) ProtoMessage() {}

func (x *SubmitAvailabilityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubmitAvailabilityRequest.ProtoReflect.Descriptor instead.
func (*SubmitAvailabilityRequest) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{5}
}

func (x *SubmitAvailabilityRequest) GetSlots() []*AvailabilitySlotInput {
	if x != nil {
		return x.Slots
	}
	return nil
}

// Submit availability response
type SubmitAvailabilityResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Successfully created slots
	CreatedSlots []*AvailabilitySlot `protobuf:"bytes,1,rep,name=created_slots,json=createdSlots,proto3" json:"created_slots,omitempty"`
	// Number of slots created
	CreatedCount int32 `protobuf:"varint,2,opt,name=created_count,json=createdCount,proto3" json:"created_count,omitempty"`
	// Validation errors for rejected slots (slot index -> error message)
	ValidationErrors map[int32]string `protobuf:"bytes,3,rep,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Success message
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubmitAvailabilityResponse) Reset() {
	*x = SubmitAvailabilityResponse{}
	mi := &file_availability_v1_availability_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubmitAvailabilityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubmitAvailabilityResponse) ProtoMessage() {}

func (x *SubmitAvailabilityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubmitAvailabilityResponse.ProtoReflect.Descriptor instead.
func (*SubmitAvailabilityResponse) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{6}
}

func (x *SubmitAvailabilityResponse) GetCreatedSlots() []*AvailabilitySlot {
	if x != nil {
		return x.CreatedSlots
	}
	return nil
}

func (x *SubmitAvailabilityResponse) GetCreatedCount() int32 {
	if x != nil {
		return x.CreatedCount
	}
	return 0
}

func (x *SubmitAvailabilityResponse) GetValidationErrors() map[int32]string {
	if x != nil {
		return x.ValidationErrors
	}
	return nil
}

func (x *SubmitAvailabilityResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// Delete availability request
type DeleteAvailabilityRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Slot ID to delete
	SlotId        string `protobuf:"bytes,1,opt,name=slot_id,json=slotId,proto3" json:"slot_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAvailabilityRequest) Reset() {
	*x = DeleteAvailabilityRequest{}
	mi := &file_availability_v1_availability_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAvailabilityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAvailabilityRequest) ProtoMessage() {}

func (x *DeleteAvailabilityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAvailabilityRequest.ProtoReflect.Descriptor instead.
func (*DeleteAvailabilityRequest) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{7}
}

func (x *DeleteAvailabilityRequest) GetSlotId() string {
	if x != nil {
		return x.SlotId
	}
	return ""
}

// Delete availability response
type DeleteAvailabilityResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Success flag
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Message
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAvailabilityResponse) Reset() {
	*x = DeleteAvailabilityResponse{}
	mi := &file_availability_v1_availability_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAvailabilityResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAvailabilityResponse) ProtoMessage() {}

func (x *DeleteAvailabilityResponse) ProtoReflect() protoreflect.Message {
	mi := &file_availability_v1_availability_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAvailabilityResponse.ProtoReflect.Descriptor instead.
func (*DeleteAvailabilityResponse) Descriptor() ([]byte, []int) {
	return file_availability_v1_availability_proto_rawDescGZIP(), []int{8}
}

func (x *DeleteAvailabilityResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DeleteAvailabilityResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

var File_availability_v1_availability_proto protoreflect.FileDescriptor

const file_availability_v1_availability_proto_rawDesc = "" +
	"\n" +
	"\"availability/v1/availability.proto\x12\x17datifyy.availability.v1\x1a\x15common/v1/types.proto\"\xb2\x02\n" +
	"\x0fOfflineLocation\x12\x1d\n" +
	"\n" +
	"place_name\x18\x01 \x01(\tR\tplaceName\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x12\n" +
	"\x04city\x18\x03 \x01(\tR\x04city\x12\x14\n" +
	"\x05state\x18\x04 \x01(\tR\x05state\x12\x18\n" +
	"\acountry\x18\x05 \x01(\tR\acountry\x12\x18\n" +
	"\azipcode\x18\x06 \x01(\tR\azipcode\x12\x1a\n" +
	"\blatitude\x18\a \x01(\x01R\blatitude\x12\x1c\n" +
	"\tlongitude\x18\b \x01(\x01R\tlongitude\x12&\n" +
	"\x0fgoogle_place_id\x18\t \x01(\tR\rgooglePlaceId\x12&\n" +
	"\x0fgoogle_maps_url\x18\n" +
	" \x01(\tR\rgoogleMapsUrl\"\xa3\x03\n" +
	"\x10AvailabilitySlot\x12\x17\n" +
	"\aslot_id\x18\x01 \x01(\tR\x06slotId\x12\x17\n" +
	"\auser_id\x18\x02 \x01(\tR\x06userId\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x04 \x01(\x03R\aendTime\x12>\n" +
	"\tdate_type\x18\x05 \x01(\x0e2!.datifyy.availability.v1.DateTypeR\bdateType\x12S\n" +
	"\x10offline_location\x18\x06 \x01(\v2(.datifyy.availability.v1.OfflineLocationR\x0fofflineLocation\x12\x14\n" +
	"\x05notes\x18\a \x01(\tR\x05notes\x12;\n" +
	"\n" +
	"created_at\x18\b \x01(\v2\x1c.datifyy.common.v1.TimestampR\tcreatedAt\x12;\n" +
	"\n" +
	"updated_at\x18\t \x01(\v2\x1c.datifyy.common.v1.TimestampR\tupdatedAt\"\xfc\x01\n" +
	"\x15AvailabilitySlotInput\x12\x1d\n" +
	"\n" +
	"start_time\x18\x01 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x02 \x01(\x03R\aendTime\x12>\n" +
	"\tdate_type\x18\x03 \x01(\x0e2!.datifyy.availability.v1.DateTypeR\bdateType\x12S\n" +
	"\x10offline_location\x18\x04 \x01(\v2(.datifyy.availability.v1.OfflineLocationR\x0fofflineLocation\x12\x14\n" +
	"\x05notes\x18\x05 \x01(\tR\x05notes\"\xad\x01\n" +
	"\x16GetAvailabilityRequest\x12\x17\n" +
	"\auser_id\x18\x01 \x01(\tR\x06userId\x12\x1b\n" +
	"\tfrom_time\x18\x02 \x01(\x03R\bfromTime\x12\x17\n" +
	"\ato_time\x18\x03 \x01(\x03R\x06toTime\x12D\n" +
	"\n" +
	"pagination\x18\x04 \x01(\v2$.datifyy.common.v1.PaginationRequestR\n" +
	"pagination\"\xa1\x01\n" +
	"\x17GetAvailabilityResponse\x12?\n" +
	"\x05slots\x18\x01 \x03(\v2).datifyy.availability.v1.AvailabilitySlotR\x05slots\x12E\n" +
	"\n" +
	"pagination\x18\x02 \x01(\v2%.datifyy.common.v1.PaginationResponseR\n" +
	"pagination\"a\n" +
	"\x19SubmitAvailabilityRequest\x12D\n" +
	"\x05slots\x18\x01 \x03(\v2..datifyy.availability.v1.AvailabilitySlotInputR\x05slots\"\xe8\x02\n" +
	"\x1aSubmitAvailabilityResponse\x12N\n" +
	"\rcreated_slots\x18\x01 \x03(\v2).datifyy.availability.v1.AvailabilitySlotR\fcreatedSlots\x12#\n" +
	"\rcreated_count\x18\x02 \x01(\x05R\fcreatedCount\x12v\n" +
	"\x11validation_errors\x18\x03 \x03(\v2I.datifyy.availability.v1.SubmitAvailabilityResponse.ValidationErrorsEntryR\x10validationErrors\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\x1aC\n" +
	"\x15ValidationErrorsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"4\n" +
	"\x19DeleteAvailabilityRequest\x12\x17\n" +
	"\aslot_id\x18\x01 \x01(\tR\x06slotId\"P\n" +
	"\x1aDeleteAvailabilityResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage*o\n" +
	"\bDateType\x12\x19\n" +
	"\x15DATE_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10DATE_TYPE_ONLINE\x10\x01\x12\x15\n" +
	"\x11DATE_TYPE_OFFLINE\x10\x02\x12\x1b\n" +
	"\x17DATE_TYPE_OFFLINE_EVENT\x10\x032\x89\x03\n" +
	"\x13AvailabilityService\x12t\n" +
	"\x0fGetAvailability\x12/.datifyy.availability.v1.GetAvailabilityRequest\x1a0.datifyy.availability.v1.GetAvailabilityResponse\x12}\n" +
	"\x12SubmitAvailability\x122.datifyy.availability.v1.SubmitAvailabilityRequest\x1a3.datifyy.availability.v1.SubmitAvailabilityResponse\x12}\n" +
	"\x12DeleteAvailability\x122.datifyy.availability.v1.DeleteAvailabilityRequest\x1a3.datifyy.availability.v1.DeleteAvailabilityResponseB\xed\x01\n" +
	"\x1bcom.datifyy.availability.v1B\x11AvailabilityProtoP\x01Z=github.com/datifyy/backend/gen/availability/v1;availabilityv1\xa2\x02\x03DAX\xaa\x02\x17Datifyy.Availability.V1\xca\x02\x17Datifyy\\Availability\\V1\xe2\x02#Datifyy\\Availability\\V1\\GPBMetadata\xea\x02\x19Datifyy::Availability::V1b\x06proto3"

var (
	file_availability_v1_availability_proto_rawDescOnce sync.Once
	file_availability_v1_availability_proto_rawDescData []byte
)

func file_availability_v1_availability_proto_rawDescGZIP() []byte {
	file_availability_v1_availability_proto_rawDescOnce.Do(func() {
		file_availability_v1_availability_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_availability_v1_availability_proto_rawDesc), len(file_availability_v1_availability_proto_rawDesc)))
	})
	return file_availability_v1_availability_proto_rawDescData
}

var file_availability_v1_availability_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_availability_v1_availability_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_availability_v1_availability_proto_goTypes = []any{
	(DateType)(0),                      // 0: datifyy.availability.v1.DateType
	(*OfflineLocation)(nil),            // 1: datifyy.availability.v1.OfflineLocation
	(*AvailabilitySlot)(nil),           // 2: datifyy.availability.v1.AvailabilitySlot
	(*AvailabilitySlotInput)(nil),      // 3: datifyy.availability.v1.AvailabilitySlotInput
	(*GetAvailabilityRequest)(nil),     // 4: datifyy.availability.v1.GetAvailabilityRequest
	(*GetAvailabilityResponse)(nil),    // 5: datifyy.availability.v1.GetAvailabilityResponse
	(*SubmitAvailabilityRequest)(nil),  // 6: datifyy.availability.v1.SubmitAvailabilityRequest
	(*SubmitAvailabilityResponse)(nil), // 7: datifyy.availability.v1.SubmitAvailabilityResponse
	(*DeleteAvailabilityRequest)(nil),  // 8: datifyy.availability.v1.DeleteAvailabilityRequest
	(*DeleteAvailabilityResponse)(nil), // 9: datifyy.availability.v1.DeleteAvailabilityResponse
	nil,                                // 10: datifyy.availability.v1.SubmitAvailabilityResponse.ValidationErrorsEntry
	(*v1.Timestamp)(nil),               // 11: datifyy.common.v1.Timestamp
	(*v1.PaginationRequest)(nil),       // 12: datifyy.common.v1.PaginationRequest
	(*v1.PaginationResponse)(nil),      // 13: datifyy.common.v1.PaginationResponse
}
var file_availability_v1_availability_proto_depIdxs = []int32{
	0,  // 0: datifyy.availability.v1.AvailabilitySlot.date_type:type_name -> datifyy.availability.v1.DateType
	1,  // 1: datifyy.availability.v1.AvailabilitySlot.offline_location:type_name -> datifyy.availability.v1.OfflineLocation
	11, // 2: datifyy.availability.v1.AvailabilitySlot.created_at:type_name -> datifyy.common.v1.Timestamp
	11, // 3: datifyy.availability.v1.AvailabilitySlot.updated_at:type_name -> datifyy.common.v1.Timestamp
	0,  // 4: datifyy.availability.v1.AvailabilitySlotInput.date_type:type_name -> datifyy.availability.v1.DateType
	1,  // 5: datifyy.availability.v1.AvailabilitySlotInput.offline_location:type_name -> datifyy.availability.v1.OfflineLocation
	12, // 6: datifyy.availability.v1.GetAvailabilityRequest.pagination:type_name -> datifyy.common.v1.PaginationRequest
	2,  // 7: datifyy.availability.v1.GetAvailabilityResponse.slots:type_name -> datifyy.availability.v1.AvailabilitySlot
	13, // 8: datifyy.availability.v1.GetAvailabilityResponse.pagination:type_name -> datifyy.common.v1.PaginationResponse
	3,  // 9: datifyy.availability.v1.SubmitAvailabilityRequest.slots:type_name -> datifyy.availability.v1.AvailabilitySlotInput
	2,  // 10: datifyy.availability.v1.SubmitAvailabilityResponse.created_slots:type_name -> datifyy.availability.v1.AvailabilitySlot
	10, // 11: datifyy.availability.v1.SubmitAvailabilityResponse.validation_errors:type_name -> datifyy.availability.v1.SubmitAvailabilityResponse.ValidationErrorsEntry
	4,  // 12: datifyy.availability.v1.AvailabilityService.GetAvailability:input_type -> datifyy.availability.v1.GetAvailabilityRequest
	6,  // 13: datifyy.availability.v1.AvailabilityService.SubmitAvailability:input_type -> datifyy.availability.v1.SubmitAvailabilityRequest
	8,  // 14: datifyy.availability.v1.AvailabilityService.DeleteAvailability:input_type -> datifyy.availability.v1.DeleteAvailabilityRequest
	5,  // 15: datifyy.availability.v1.AvailabilityService.GetAvailability:output_type -> datifyy.availability.v1.GetAvailabilityResponse
	7,  // 16: datifyy.availability.v1.AvailabilityService.SubmitAvailability:output_type -> datifyy.availability.v1.SubmitAvailabilityResponse
	9,  // 17: datifyy.availability.v1.AvailabilityService.DeleteAvailability:output_type -> datifyy.availability.v1.DeleteAvailabilityResponse
	15, // [15:18] is the sub-list for method output_type
	12, // [12:15] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_availability_v1_availability_proto_init() }
func file_availability_v1_availability_proto_init() {
	if File_availability_v1_availability_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_availability_v1_availability_proto_rawDesc), len(file_availability_v1_availability_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_availability_v1_availability_proto_goTypes,
		DependencyIndexes: file_availability_v1_availability_proto_depIdxs,
		EnumInfos:         file_availability_v1_availability_proto_enumTypes,
		MessageInfos:      file_availability_v1_availability_proto_msgTypes,
	}.Build()
	File_availability_v1_availability_proto = out.File
	file_availability_v1_availability_proto_goTypes = nil
	file_availability_v1_availability_proto_depIdxs = nil
}
